#!/usr/bin/env perl
use strict;
use warnings;

# Arrange the binary bits of pi in a square grid, and use as the
# initial GoL state.
# A stable state is reached at the 832nd iteration for a 48x48 surface.

# After running this and generating the GoL frames. Use ImageMagick to
# possibly increase the size:
# $ convert 'init-pi-life-%04d.png[0-629]' -resize 192x192 'resized/resized%04d.png'
# Then turn them into an animated gif:
# $ convert -delay 60 resized/resized*.png animated-pi-life.gif

use File::Slurper qw(read_text write_text);
use Game::Life ();
use Imager ();
use Math::BigFloat ();

my $iteration = shift || 630;     # How many game frames?
my $row_size  = shift || 48 * 2;  # Size of the image in pixels

my $max = $row_size * $row_size / 3; # Approximate number of pi decimal digits needed

my $path = 'life'; # Subdirectory to house the generated frames

my $pi_digits_file = 'pi-digits-' . $max . '.txt'; # The file to hold our digits of pi

my $decimal; # The decimal digits

print "Gathering $max decimals of pi...\n";
# Use the file of digits if it exists
if (-e $pi_digits_file) {
    $decimal = read_text($pi_digits_file);
    chomp $decimal;
}
else { # Get the digits ... very slow
    ($decimal = Math::BigFloat->bpi($max)) =~ s/^3\.(.+)$/$1/;
    write_text($pi_digits_file, $decimal);
}

my $init = []; # The initial GoL state

# Keep track of grid position
my $i = 0;
my $j = 0;

print "Building a $row_size x $row_size initial grid...\n";
for my $n (split //, $decimal) {
    last if $i >= $row_size;

    my $binary = sprintf '%04b', $n; # Turn a 0-9 digit into a binary number

    # Add the bits to the grid
    for my $bit (split //, $binary) {
        push $init->[$i]->@*, $bit;

        # Make sure we stay within the row (j)
        # and within the number of rows (i)
        $j++;
        if ($j >= $row_size) {
            $i++;
            $j = 0;
        }
        last if $i >= $row_size;
    }
}

# Make a new canvas and colors
my $img   = Imager->new(xsize => $row_size, ysize => $row_size);
my $black = Imager::Color->new(  0,   0,   0);
my $white = Imager::Color->new(255, 255, 255);

# Make a new game of life
my $game = Game::Life->new($row_size);
$game->place_points(0, 0, $init);

print "Rendering $iteration game of life frames...\n";
for my $n (0 .. $iteration - 1) {
    $j = 0;

    my $grid = $game->get_grid;

    for my $row ($grid->@*) {
        $i = 0;

        for my $bit ($row->@*) {
            my $color = $bit ? $black : $white; # NB: Invert the game by swapping colors here

            $img->setpixel(x => $i, y => $j, color => $color);

            $i++;
        }

        $j++;
    }

    # Write the image frame to disk
    $img->write(file => sprintf '%s/%s-%04d.png', $path, $0, $n)
        or die $img->errstr;

    $game->process;
}
