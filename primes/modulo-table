#!/usr/bin/perl
#
# Compute a table of primes x modulo arithmetic for a given ceiling of primes
# and a maximum number to modulo by.
# -- gene@cpan.org
# Ex: $ perl modulo-table 55 90
#     $ perl modulo-table 3 10 11 1000
#
use strict;
use warnings;

use Math::Big qw(primes);

# Crude but handy debug flag.
my $DEBUG = 1;

# Set the starting modulo value.
my $mmin = shift || 2;
# Set the upper modulo limit.
my $mmax = shift || 20;
# Set the starting prime value.
my $pmin = shift || $mmin;
# Set the ceiling for primes to consider.
my $pmax = shift || $mmax;

# Get a list of the bounded primes only.
my @primes = grep { $_->{value}[0] if $_->{value}[0] >= $pmin } primes($pmax);
if ($DEBUG) {
    printf("There are %d primes >= %d but < %d.\n",
        scalar(@primes), $pmin, $pmax);
    print "Table: Prime rows x modulo columns:\n";
}

# Set the field widths for output formatting.
my $mwidth = length($mmax);
my $pwidth = length($primes[-1]);
my $iwidth = length(@primes);

# Display the table header.
printf("%s", (' ' x ($iwidth + $pwidth + $mwidth + 1))) if $DEBUG;
printf("%s\n", join(' ', (map { sprintf('%*d', $mwidth, $_) } $mmin .. $mmax)));

# Generate the table of primes x modulo arithmetic.
my $i = 0;
for my $p (@primes) {
    # Start off a row with the number and prime.
    printf('%*d. %*d ', $iwidth, ++$i, $pwidth, $p) if $DEBUG;
    # Compute each modulo of the prime.
    for my $m ($mmin .. $mmax) {
        printf '%*d ', $mwidth, $p % $m;
    }
    # Conclude our row.
    print "\n";
}
