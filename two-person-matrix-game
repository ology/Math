#!/usr/bin/env perl
use strict;
use warnings;

use Data::Dumper;
use Algorithm::Combinatorics qw( variations_with_repetition );
use List::Util qw( max );
use List::MoreUtils qw( all indexes mesh each_array );

# Player strategies.
my $p1 = {
    # Reducible
    1 => [1,1,3],
    2 => [0,0,3],
    3 => [0,2,5],
    # Irreducible. Nash
#    1 => [1,0,1],
#    2 => [0,1,0],
    # Irreducible. No Nash
#    1 => [0,3],
#    2 => [2,1],
};
my $p2 = {
    # Reducible
    1 => [0,2,2],
    2 => [3,1,4],
    3 => [0,0,3],
    # Irreducible. Nash
#    1 => [1,0,1],
#    2 => [0,1,0],
    # Irreducible. No Nash
#    1 => [3,1],
#    2 => [0,2],
};

# Solve reducible game.
reduce_game($p2, $p1);
reduce_game($p1, $p2);
reduce_game($p2, $p1);
reduce_game($p1, $p2);
#warn 'Players:',Data::Dumper->new([$p1,$p2])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

my $nash = nash($p1, $p2);
warn 'Nash:',Data::Dumper->new([$nash])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

sub reduce_game {
    my ($player, $opponent) = @_;

    # Declare the bucket of "X given Y" strategy pair utilities.
    my $utility = {};
    #my $metric  = {};

    # Evaluate pairs of strategies.
    my $iter = variations_with_repetition([keys %$player], 2);
    while (my $v = $iter->next) {
        # Skip "X|X" pairs.
        next if $v->[0] eq $v->[1];

        # Inspect each stategy utility.
        #warn join(', ', @$v), "\n";
        for my $i (0 .. @$v - 1) {
            # Skip undefined utilities.
            if (defined $player->{$v->[0]}[$i] && defined $player->{$v->[1]}[$i]) {
                # Add a relative utility indicator.
                #warn "$i: $player->{$v->[0]}[$i] vs $player->{$v->[1]}[$i]\n";
                if ($player->{$v->[0]}[$i] > $player->{$v->[1]}[$i]) {
                    # Strictly dominant utility
                    push @{ $utility->{join '|', @$v} }, 1;
                }
                elsif ($player->{$v->[0]}[$i] < $player->{$v->[1]}[$i]) {
                    # Strictly dominated utility
                    push @{ $utility->{join '|', @$v} }, -1;
                }
                else {
                    # Equivalent utility
                    push @{ $utility->{join '|', @$v} }, 0;
                }

                # Track the actual relative utility metric.
                #push @{ $metric->{join '|', @$v} }, $player->{$v->[0]}[$i] - $player->{$v->[1]}[$i];
            }
        }
    }
    #warn 'Utility:',Data::Dumper->new([$utility])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
    #warn 'Metric:',Data::Dumper->new([$metric])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

    # Remove strictly dominated strategies.
    for my $strat (keys %$utility) {
        if (all { $_ == -1 } @{$utility->{$strat}}) {
            my @dominated = split /\|/, $strat;
            #warn "U:[@{$utility->{$strat}}]\n";
            #warn "D:'$dominated[0]'\n";
            delete $player->{$dominated[0]};
            # Remove the utilities for the deleted opponent strategy.
            for my $u (keys %$opponent) {
                splice @{$opponent->{$u}}, $dominated[0] - 1, 1;
                #warn "u:'@{$opponent->{$u}}'\n";
            }
            last;
        } 
    }
}

sub nash {
    my ($player, $opponent) = @_;

    # Inspect each player item for strategic equilibrium.
    my %x; # Max utility indexes.
    # Inspect the strategies of the player.
    for my $u ( sort { $a <=> $b } keys %$player ) {
        # Find the maximum utility for the strategy.
        my $max = max @{ $player->{$u} };
        # Get the "strategically most desirable" indexes.
        $x{$u} = [ indexes { $_ >= $max } @{ $player->{$u} } ];
    }
    # Inspect each opponent item for strategic equilibrium.
    my %y;
    for my $u ( sort { $a <=> $b } keys %$opponent ) {
        my $max = max @{ $opponent->{$u} };
        $y{$u} = [ indexes { $_ >= $max } @{ $opponent->{$u} } ];
    }
warn 'X:',Data::Dumper->new([\%x])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
warn 'Y:',Data::Dumper->new([\%y])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

    # Identify the equilibria.
    my $nash = {};
    my @xstrat = sort { $a <=> $b } keys %x;
    my @ystrat = sort { $a <=> $b } keys %y;
#warn 'Xstrat:',Data::Dumper->new([\@xstrat])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
#warn 'Ystrat:',Data::Dumper->new([\@ystrat])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;
    my $estrat = each_array(@xstrat, @ystrat);
    while ( my ($xs, $ys) = $estrat->() ) {
        #warn "xs:'@{$x{$xs}}'\n";
        #warn "ys:'@{$y{$ys}}'\n";
        my $eutil = each_array(@{$x{$xs}}, @{$y{$ys}});
        while ( my ( $i, $j ) = $eutil->() ) {
            if ( $i == $j ) {
                #warn "$xs,$ys: $i == $j\n";
                $nash->{"$xs,$ys"} = [ $player->{$xs}[$i], $opponent->{$ys}->[$j] ];
            }
        }
    }

    return $nash;
}
