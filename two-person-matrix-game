#!/usr/bin/env perl
use strict;
use warnings;

use Data::Dumper;
use Algorithm::Combinatorics qw( variations_with_repetition );
use List::Util qw( max );
use List::MoreUtils qw( all indexes );

# Player strategies.
my $p1 = {
    # Reducible
#    1 => [1,1,3],
#    2 => [0,0,3],
#    3 => [0,2,5],
    # Irreducible. Nash
    1 => [1,0],
    2 => [0,1],
    # Irreducible. No Nash
#    1 => [0,3],
#    2 => [2,1],
};
my $p2 = {
    # Reducible
#    1 => [0,2,2],
#    2 => [3,1,4],
#    3 => [0,0,3],
    # Irreducible. Nash
    1 => [1,0],
    2 => [0,1],
    # Irreducible. No Nash
#    1 => [3,1],
#    2 => [0,2],
};

# Solve reducible game.
#reduce_game($p2, $p1);
#reduce_game($p1, $p2);
#reduce_game($p2, $p1);
#reduce_game($p1, $p2);

nash($p1, $p2);
warn Data::Dumper->new([$p1,$p2])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

sub reduce_game {
    my ($player, $opponent) = @_;

    # Declare the bucket of "X given Y" strategy pair utilities.
    my $utility = {};
    #my $metric  = {};

    # Evaluate pairs of strategies.
    my $iter = variations_with_repetition([keys %$player], 2);
    while (my $v = $iter->next) {
        # Skip "X|X" pairs.
        next if $v->[0] eq $v->[1];

        # Inspect each stategy utility.
        #warn join(', ', @$v), "\n";
        for my $i (0 .. @$v - 1) {
            # Skip undefined utilities.
            if (defined $player->{$v->[0]}[$i] && defined $player->{$v->[1]}[$i]) {
                # Add a relative utility indicator.
                #warn "$i: $player->{$v->[0]}[$i] vs $player->{$v->[1]}[$i]\n";
                if ($player->{$v->[0]}[$i] > $player->{$v->[1]}[$i]) {
                    # Strictly dominant utility
                    push @{ $utility->{join '|', @$v} }, 1;
                }
                elsif ($player->{$v->[0]}[$i] < $player->{$v->[1]}[$i]) {
                    # Strictly dominated utility
                    push @{ $utility->{join '|', @$v} }, -1;
                }
                else {
                    # Equivalent utility
                    push @{ $utility->{join '|', @$v} }, 0;
                }

                # Track the actual relative utility metric.
                #push @{ $metric->{join '|', @$v} }, $player->{$v->[0]}[$i] - $player->{$v->[1]}[$i];
            }
        }
    }
    #warn Data::Dumper->new([$metric])->Indent(1)->Terse(1)->Quotekeys(0)->Sortkeys(1)->Dump;

    # Remove strictly dominated strategies.
    for my $strat (keys %$utility) {
        if (all { $_ == -1 } @{$utility->{$strat}}) {
            my @dominated = split /\|/, $strat;
            #warn "U:[@{$utility->{$strat}}]\n";
            #warn "D:'$dominated[0]'\n";
            delete $player->{$dominated[0]};
            # Remove the utilities for the deleted opponent strategy.
            for my $u (keys %$opponent) {
                splice @{$opponent->{$u}}, $dominated[0] - 1, 1;
                #warn "u:'@{$opponent->{$u}}'\n";
            }
            last;
        } 
    }
}

sub nash {
    my ($player, $opponent) = @_;

    # Inspect each player item for strategic equilibrium.
    my $i = 1; # TODO Fix hardcoded column names.
    for my $p_u ( sort { $a <=> $b } keys %$player ) {
        my $pmax = max @{ $player->{$p_u} };
        my @j = indexes { $_ >= $pmax } @{ $player->{$p_u} };
        warn 'Ps',$i,":'@j'\n";
        $i++;
    }

    # Inspect each opponent item for strategic equilibrium.
    $i = 1; # TODO Fix hardcoded column names.
    for my $o_u ( sort { $a <=> $b } keys %$opponent ) {
        my $omax = max @{ $opponent->{$o_u} };
        my @j = indexes { $_ >= $omax } @{ $opponent->{$o_u} };
        warn 'Os',$i,":'@j'\n";
        $i++;
    }
}
